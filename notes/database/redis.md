### Redis

#### 为什么使用redis

使用redis主要是从两个角度去考虑：性能和并发。
1. 碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。
2. 在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。


#### 使用redis有什么缺点

主要是四个问题：
1. 缓存和数据库双写一致性问题：一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。因此如果对数据有强一致性要求，不能放缓存。
2. 缓存雪崩问题：即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。
解决方案:
3. 缓存击穿问题：即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。
4. 缓存的并发竞争问题：同时有多个子系统去set一个key。


#### 单线程的redis为什么这么快

主要是以下三点
1. 纯内存操作
2. 单线程操作，避免了频繁的上下文切换
3. 采用了非阻塞I/O多路复用机制


#### redis的数据类型，以及每种数据类型的使用场景

1. String：最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。
2. hash：这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。
3. list：使用List的数据结构，可以做简单的消息队列的功能。另外可以利用lrange命令，做基于redis的分页功能。
4. set：放的是一堆不重复值的集合，所以可以做全局去重的功能。可以利用交集、并集、差集等操作，计算共同喜好，全部的喜好，自己独有的喜好等功能。
5. sorted set：sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。


#### redis的过期策略以及内存淘汰机制

redis采用的是定期删除+惰性删除策略。

为什么不用定时删除策略?
定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略。

定期删除+惰性删除是如何工作的呢?
定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。
于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。

采用定期删除+惰性删除就没其他问题了么?
不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。


#### 如何应对缓存穿透和缓存雪崩问题

缓存穿透解决方案:
1. 利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试
2. 采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。
3. 提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。

缓存雪崩解决方案:
1. 给缓存的失效时间，加上一个随机值，避免集体失效。
2. 使用互斥锁，但是该方案吞吐量明显下降了。
3. 双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点：
 - 从缓存A读数据库，有则直接返回
 - A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。
 - 更新线程同时更新缓存A和缓存B。


#### 如何解决redis的并发竞争key问题

1. 如果对这个key操作，不要求顺序：
这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。

2. 如果对这个key操作，要求顺序：
假设有一个key1，系统A需要将key1设置为valueA，系统B需要将key1设置为valueB，系统C需要将key1设置为valueC。期望按照key1的value值按照 valueA-->valueB-->valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。set操作时对比时间戳，如果早于缓存中的时间戳，那就不做set操作了。另外的方法如利用队列，将set方法变成串行访问也可以实现顺序操作。
